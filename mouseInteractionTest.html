<html>
  <head>
    <title>Three.js Example Template</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>
  <body>
    <!--
      Template for creating synaesthetics
      Load libraries from lib/ and load scene-specifics from js/
      Stay positive, stay focused, make some cool stuff
    -->
    <script src="lib/three.js"></script>
    <script src="lib/ShaderLoader.js"></script>
    <script src="lib/AudioController.js"></script>
    <script src="lib/Stream.js"></script>
    <script src="lib/AudioTexture.js"></script>
    <script src="lib/TrackballControls.js"></script>
    <script src="lib/FirstPersonControls.js"></script>
    <script src="lib/ObjectControls.js"></script>


    <script src="lib/shaders/CopyShader.js"></script>
    <script src="lib/shaders/DotScreenShader.js"></script>
    <script src="lib/shaders/RGBShiftShader.js"></script>    
    
    <script src="lib/postprocessing/EffectComposer.js"></script>
    <script src="lib/postprocessing/MaskPass.js"></script>
    <script src="lib/postprocessing/RenderPass.js"></script>
    <script src="lib/postprocessing/ShaderPass.js"></script>
    
    <!-- Main Script -->
    <script>
      //COLOR PALETTE:
      //LIGHT BLUE: 54,196,216 #36C4D8
      //RED: 214,51,52 #D63334
      //YELLOW: 243,215,71 #F3D847
      //LAVENDER: 177,111,173 #B16FAD
      //

      // General three.js variables
      var camera, controls, scene, renderer, projector;
      // If using post-processor - send scene to EffectComposer
      var composer;
      var cameraDummy;

      renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
      renderer.setClearColor( 0xaaccff );


      window.addEventListener( 'resize', onWindowResize, false );
      document.addEventListener( 'mousemove', onDocumentMouseMove, false );

      //time
      var clock = new THREE.Clock();

      // Scene-Specific Variables
      var floor, floorGeometry, floorTexture, 
      sunMesh, sunGeometry, sunTexture,
      coronaMesh, coronaGeometry, coronaTexture;

      var spriteA, numSprites;
      var superSprite = [];
      var superCollider = [];
      var map1, map2, gifMat1, gifMat2;

      var floorSmoothing = 0.1;

      // Ground Geo Vars
      var worldWidth = 32, worldDepth = 32,
      worldHalfWidth = worldWidth/2, worldHalfDepth = worldDepth/2;
      

      //Audio Vars
      var audioController = new AudioController();
      var stream = new Stream('Lazy.mp3', audioController );
      // Object related variables
      // Light-related variables, modify as needed

      var light, light2;

      //Raycaster
      var raycaster, mouse, INTERSECTED;
      var sceneSprites;

      // If you're using functions to encapsulate functionality do the following:
      // 1. Include the functons between init() and animate()
      // 2. Make damn sure that you don't redeclare variables inside the functions (don't use var twice)
      //     as this will cause the code to fail

      init();
      animate();
      function init() {
        // Step 1 : Add Scene
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2( 0xaaccff, 0.0007 );

        // Step 2 : Add Camera
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.up.set(0,1,0);
        camera.position.y = 600;

        scene.add( camera );
        cameraDummy = new THREE.Object3D;
        cameraDummy.position.set(camera.position.x, camera.position.y, camera.position.z);

        scene.add( cameraDummy );

        // Step 2b : Controls
       // controls = new THREE.FirstPersonControls(camera);
        //controls.movementSpeed = 10;
       // controls.lookSpeed = 0.1;

        // Step 2c : Raycaster and Mouse
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        // mouse.x = controls.mouseX;
        // mouse.y = controls.mouseY;
       


        // Step 3 : Add stuff
        floorMaterial = new THREE.MeshPhongMaterial( {shading : THREE.FlatShading} );
        floorGeometry = new THREE.PlaneGeometry(10000, 10000, worldWidth, worldDepth);
        floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y -= 800;
        floor.rotateOnAxis(new THREE.Vector3(1,0,0), - Math.PI / 2 );
        scene.add(floor);

        sunGeometry = new THREE.SphereGeometry(100, 32, 32);
        sunMaterial = new THREE.MeshPhongMaterial ({
          color: 0xF3D847,
          emissive: 0xffde00,
          specular: 0xffffff,
          wireframe: false
        });
        sunMesh = new THREE.Mesh( sunGeometry, sunMaterial);

        coronaGeometry = new THREE.IcosahedronGeometry(200, 1);
        coronaMaterial = new THREE.MeshPhongMaterial ({
          color: 0xF3D847,
          emissive: 0xffde00,
          specular: 0xffffff,
          wireframe: true
        });
        coronaMesh = new THREE.Mesh( coronaGeometry, coronaMaterial);
        sunMesh.add(coronaMesh);
        
        numSprites = 50;
        var textureLoader = new THREE.TextureLoader();
        map1 = textureLoader.load("Texture2.png");
        map2 = textureLoader.load("HoverTexture.png");
        // for Lazy Heart - duration = 468/num frames
        spriteA = new TextureAnimator( map1, 8, 1, 8, 78 ); // texture, #horiz, #vert, #total, duration.
        gifMat1 = new THREE.SpriteMaterial( { map: map1, color: 0xffffff, fog: true } );
        hoverSprite = new TextureAnimator( map2, 6, 1, 6, 78 ); // texture, #horiz, #vert, #total, duration.
        gifMat2 = new THREE.SpriteMaterial( { map: map2, color: 0xffffff, fog: true } );

        var colGeometry = new THREE.PlaneGeometry( 2, 2, 32 );
        var colMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff, side: THREE.DoubleSide, visible: false} );
        sceneSprites = new THREE.Object3D;
        for (var i = 0; i < numSprites; i++) {

          var gifMat = new THREE.SpriteMaterial( { map: map1, color: 0xffffff, fog: true } );

          var superSprite= new THREE.Sprite(gifMat);
          
          superSprite.position.x = (camera.position.x + Math.random()*25 - 25);
          superSprite.position.y = (camera.position.y + Math.random()*25 - 25);
          superSprite.position.z = (camera.position.z + Math.random()*25 - 25);



          
          superCollider[i] = new THREE.Mesh( colGeometry, colMaterial );
          
          sceneSprites.add(superSprite);
          scene.add(superCollider[i]);

          
          superSprite.add(superCollider[i]);

        }

        scene.add(sceneSprites)

        //objControls.add(superCollider);
        

        
  

        //scene.add( sunMesh );
        cameraDummy.add(sunMesh);
        sunMesh.position.set(0, 600, -1000);
        //console.log(sunMesh.position);

        
        // If you will not use functions to create the light sources, then put them below
        light = new THREE.PointLight( 0xffffff);
        light.position.set( 0,20,20 );

        light2 = new THREE.PointLight( 0xff00ff );
        light2.position.set( 0, 200, 50 );

        light3 = new THREE.AmbientLight( 0x404040 );
        light3.position.set(camera.position );
        scene.add(light);
        scene.add(light2);
        //scene.add(light3);
        stream.play();

        ///////////////////
        //Post-Processing//
        ///////////////////


        /*composer = new THREE.EffectComposer( renderer );
        composer.addPass( new THREE.RenderPass( scene, camera ) );

        var effect = new THREE.ShaderPass( THREE.DotScreenShader );
        effect.uniforms[ 'scale' ].value = 100;
        composer.addPass( effect );

        var effect = new THREE.ShaderPass( THREE.RGBShiftShader );
        effect.uniforms[ 'amount' ].value = 0.015;
        effect.uniforms[ 'angle' ].value = Math.PI/4
        effect.renderToScreen = true;
        composer.addPass( effect );*/


        }
      

      function animate() {
        // requestAnimationFrame shim is included in Three.js, no need to create your own
        // animate() can also handle specific animation steps or they can be handled to an external function
        var delta = clock.getDelta();
        //controls.update(delta);


        spriteA.update(delta * 1000);
        hoverSprite.update(delta * 1000);

        audioController.update();

        for (var i = 0; i < audioController.analyzer.array.length; i++) {
          floorGeometry.vertices[i].z += (audioController.analyzer.array[i]*10-floorGeometry.vertices[i].z)*floorSmoothing;
        }

        for (var i = 0; i < coronaGeometry.vertices.length/2; i++) {
          coronaGeometry.vertices[i].z += (audioController.analyzer.array[i]-coronaGeometry.vertices[i].z)*floorSmoothing;
          coronaGeometry.vertices[i + coronaGeometry.vertices.length/2].z += (audioController.analyzer.array[i]-coronaGeometry.vertices[i].z)*floorSmoothing;
        }



        coronaMesh.geometry.verticesNeedUpdate = true;
        floor.geometry.verticesNeedUpdate = true;

        //cameraDummy.rotation.y += 0.01;
        //cameraDummy.rotation.y += 0.1;

        for (var i = 0; i < numSprites; i++) {
          sceneSprites.children[i].lookAt(camera.position);
        }


        requestAnimationFrame( animate );
        
        //render from composer OR Renderer NOTBOTH 
        //ToDo - make switch that detects this? 
        //composer.render();
        render();
        
 
        cameraDummy.rotation.y = camera.rotation.y;
      }

      function render () {
        //in case things get more complicated

        // find intersections

      // create a Ray with origin at the mouse position
      //   and direction into the scene (camera direction)
      
     raycaster.setFromCamera( mouse, camera );
        var intersects = raycaster.intersectObjects( sceneSprites.children );
        if ( intersects.length > 0 ) {
          if ( INTERSECTED != intersects[ 0 ].object ) {
            if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
            INTERSECTED = intersects[ 0 ].object;
            INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
            INTERSECTED.material.color.setHex( 0xff0000 );
          }
        } else {
          if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
          INTERSECTED = null;
        }

        
        //  var intersects = raycaster.intersectObjects( superCollider );

        // for ( var i = 0; i < intersects.length; i++ ) {

        //   intersects[ i ].object.material.color.set( 0x000000 );
          
        //   console.log("intersect");
        
        // } 
        
        renderer.render(scene, camera); 
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
        //composer.setSize( window.innerWidth, window.innerHeight );

      }

      function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
      }

      
      

      function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) { 
        // note: texture passed by reference, will be updated by the update function.
          
        this.tilesHorizontal = tilesHoriz;
        this.tilesVertical = tilesVert;
        // how many images does this spritesheet contain?
        //  usually equals tilesHoriz * tilesVert, but not necessarily,
        //  if there at blank tiles at the bottom of the spritesheet. 
        this.numberOfTiles = numTiles;
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
        texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

        // how long should each image be displayed?
        this.tileDisplayDuration = tileDispDuration;

        // how long has the current image been displayed?
        this.currentDisplayTime = 0;

        // which image is currently being displayed?
        this.currentTile = 0;
          
        this.update = function( milliSec ) {
          this.currentDisplayTime += milliSec;
          while (this.currentDisplayTime > this.tileDisplayDuration) {
            this.currentDisplayTime -= this.tileDisplayDuration;
            this.currentTile++;
            if (this.currentTile == this.numberOfTiles)
              this.currentTile = 0;
            var currentColumn = this.currentTile % this.tilesHorizontal;
            texture.offset.x = currentColumn / this.tilesHorizontal;
            var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
            texture.offset.y = currentRow / this.tilesVertical;
          }
        };
      }  
    </script>
  </body>
</html>


<!--   ////////////
  // CUSTOM //
  ////////////
  
  // MESHES WITH ANIMATED TEXTURES!
  
  var runnerTexture = new THREE.ImageUtils.loadTexture( 'images/run.png' );
  annie = new TextureAnimator( runnerTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
  var runnerMaterial = new THREE.MeshBasicMaterial( { map: runnerTexture, side:THREE.DoubleSide } );
  var runnerGeometry = new THREE.PlaneGeometry(50, 50, 1, 1);
  var runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
  runner.position.set(-100,25,0);
  scene.add(runner);
  
  var explosionTexture = new THREE.ImageUtils.loadTexture( 'images/explosion.jpg' );
  boomer = new TextureAnimator( explosionTexture, 4, 4, 16, 55 ); // texture, #horiz, #vert, #total, duration.
  var explosionMaterial = new THREE.MeshBasicMaterial( { map: explosionTexture } );
  var cubeGeometry = new THREE.CubeGeometry( 50, 50, 50 );
  cube = new THREE.Mesh( cubeGeometry, explosionMaterial );
  cube.position.set(0,26,0);
  scene.add(cube);

}

function animate() 
{
    requestAnimationFrame( animate );
  render();   
  update();
}

function update()
{
  var delta = clock.getDelta(); 

  annie.update(1000 * delta);
  boomer.update(1000 * delta);
  
  if ( keyboard.pressed("z") ) 
  { 
    // do something
  }
  
  controls.update();
  stats.update();
}

function render() 
{
  renderer.render( scene, camera );
}

function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) 
{ 
  // note: texture passed by reference, will be updated by the update function.
    
  this.tilesHorizontal = tilesHoriz;
  this.tilesVertical = tilesVert;
  // how many images does this spritesheet contain?
  //  usually equals tilesHoriz * tilesVert, but not necessarily,
  //  if there at blank tiles at the bottom of the spritesheet. 
  this.numberOfTiles = numTiles;
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
  texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

  // how long should each image be displayed?
  this.tileDisplayDuration = tileDispDuration;

  // how long has the current image been displayed?
  this.currentDisplayTime = 0;

  // which image is currently being displayed?
  this.currentTile = 0;
    
  this.update = function( milliSec )
  {
    this.currentDisplayTime += milliSec;
    while (this.currentDisplayTime > this.tileDisplayDuration)
    {
      this.currentDisplayTime -= this.tileDisplayDuration;
      this.currentTile++;
      if (this.currentTile == this.numberOfTiles)
        this.currentTile = 0;
      var currentColumn = this.currentTile % this.tilesHorizontal;
      texture.offset.x = currentColumn / this.tilesHorizontal;
      var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
      texture.offset.y = currentRow / this.tilesVertical;
    }
  };
}   --> 

